<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>silen | 源之于生活</title>
    <description>silen</description>
    <link>http://127.0.0.1:4000//</link>
    <atom:link href="http://127.0.0.1:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 13 Apr 2016 15:38:06 +0800</pubDate>
    <lastBuildDate>Wed, 13 Apr 2016 15:38:06 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>在服务器上使用 shadowsocks 客户端</title>
        <description>&lt;p&gt;在阿里云上装一些 npm 包的时候各种装不上，或者装 composer 包也是经常断掉。原因都在网络上，解决这个问题的方法只能是代理了。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;安装&lt;/h1&gt;

&lt;h2 id=&quot;centos&quot;&gt;CentOS&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ yum install python-pip    
$ pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ubuntu&quot;&gt;Ubuntu&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt-get install python-pip python-dev build-essential 
$ pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;配置&lt;/h1&gt;

&lt;p&gt;创建配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ vim /etc/shadowsocks.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &quot;server&quot;:&quot;x.x.x.x&quot;,             #ss服务器IP
    &quot;server_port&quot;:1035,             #ss服务器端口
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,   #本地ip
    &quot;local_port&quot;:1080,              #本地端口
    &quot;password&quot;:&quot;password&quot;,          #连接ss密码
    &quot;timeout&quot;:300,                  #等待超时
    &quot;method&quot;:&quot;rc4-md5&quot;,             #加密方式(与服务器一致)
    &quot;fast_open&quot;: false,             # true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &amp;gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可
    &quot;workers&quot;: 1                    # 工作线程数
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动shawodsocks&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ nohup sslocal -c /etc/shadowsocks.json /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
// 然后加入开机自启动
$ echo &quot; nohup sslocal -c /etc/shadowsocks.json /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&quot; /etc/rc.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看后台进程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ps aux |grep sslocal |grep -v &quot;grep&quot;
root      7587  0.1  0.1 184180  8624 pts/0    S    08:44   0:03 /usr/bin/python /usr/bin/sslocal -c /etc/shadowsocks.json /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试我们的代理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ curl --socks5 127.0.0.1:1080 http://httpbin.org/ip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回以下的样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;origin&quot;: &quot;45.124.xx.xx&quot; # 如果这个 IP 是你 shadowsocks 服务器的 IP 就 OK了。
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 01 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2016/03/shadowsocks-on-server.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2016/03/shadowsocks-on-server.html</guid>
        
        
      </item>
    
      <item>
        <title>npm 代理安装依赖</title>
        <description>&lt;p&gt;虽然已经使用了&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;淘宝 npm 镜像&lt;/a&gt;, 但是有一些包的下载地址在国外，比如 &lt;a href=&quot;https://github.com/ariya/phantomjs/&quot;&gt;phantomjs&lt;/a&gt; 的下载地址是 &lt;code&gt;https://bitbucket/xxxx&lt;/code&gt;, 没有代理的话还是会卡在这里。&lt;/p&gt;

&lt;p&gt;我的另一篇 &lt;a href=&quot;http://overtrue.me/articles/2016/03/shadowsocks-on-server.html&quot;&gt;在服务器上使用 shadowsocks 客户端&lt;/a&gt; 已经讲了如何在服务器上安装 shadowsocks 客户端，如果还不明白的可以参考。&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;a href=&quot;https://github.com/bitinn/kneesocks&quot;&gt;bitinn/kneesocks&lt;/a&gt; 来支持 npm 的 socket 代理，它的作用按我的理解是生成一个本地的 HTTP 代理。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ npm install kneesocks --production -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建本地代理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kneesocks PORT1 PORT2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要说明一下，&lt;code&gt;PORT1&lt;/code&gt; 为一个未被使用的新端口，用于 kneesocks 监听，&lt;code&gt;PORT2&lt;/code&gt; 是已经存在的本地代理，比如我们已经安装的 shadowsocks 的本地端口。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;kneesocks 1082 1080&lt;/code&gt;, 1080 为本地 shadowsocks 端口。&lt;/p&gt;

&lt;p&gt;配置 npm 代理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ npm config set http http://127.0.0.1:1082
$ npm config set https-proxy http://127.0.0.1:1082
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;注意，使用 kneesocks 端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后你就可以正常的 &lt;code&gt;npm install&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;如果你后面想去掉代理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ npm config delete http
$ npm config delete https-proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DEBUG 代理，使用以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;DEBUG=proxy kneesocks PORT1 PORT2
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 01 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2016/03/npm-proxy.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2016/03/npm-proxy.html</guid>
        
        
      </item>
    
      <item>
        <title>如何在全局 exception handler 中调用前一个定义的 handler</title>
        <description>&lt;p&gt;今天在写 &lt;a href=&quot;https://github.com/overtrue/wechat/tree/3.0&quot;&gt;overtrue/wechat 3.0&lt;/a&gt; 的时候，考虑到用户 debug 的问题。期望把日志包括产生的异常日志都记到用户配置的日志文件里。&lt;/p&gt;

&lt;p&gt;因为代码在不同的组件，不可能用 &lt;code&gt;try...catch&lt;/code&gt;。我打算使用 &lt;a href=&quot;http://php.net/manual/en/function.set-exception-handler.php&quot;&gt;set_exception_handler&lt;/a&gt; 注册一个全局异常处理器来做这事儿，但是，我这个只是一个开源组件，可能会被用户用到各种各样的环境中，所以，不能破坏原有框架或者用户自己定义的异常处理器，因为 &lt;code&gt;set_exception_handler&lt;/code&gt; 会覆盖前面设置的，所以问题就卡住了。&lt;/p&gt;

&lt;p&gt;然后我找到了 &lt;a href=&quot;http://php.net/manual/en/function.restore-exception-handler.php&quot;&gt;restore_exception_handler&lt;/a&gt;，以为找到了救命稻草，于是我把代码改成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php

class MyException extends Exception {}

set_exception_handler(function(Exception $e){
    echo &quot;Old handler:&quot;.$e-&amp;gt;getMessage();
});

set_exception_handler(function(Exception $e) {
    if ($e instanceof MyException) {
        echo &quot;New handler:&quot;.$e-&amp;gt;getMessage();
        return;
    }

    restore_exception_handler(); // 还原之前的设定然后下面再抛出

    throw $e;
});

// throw new MyException(&quot;Exception two&quot;, 1);
throw new Exception(&quot;Exception two&quot;, 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就报错了…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP Fatal error:  Cannot destroy active lambda function in /Users/overtrue/www/foo.php on line 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是 google, stackoverflow… 都无解。&lt;/p&gt;

&lt;p&gt;后来又仔细研究了文档，终于，我发现了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Returns the name of the previously defined exception handler, or NULL on error. If no previous handler was defined, NULL is also returned.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是此问题得以圆满解决，虽然恢复原有的 handler 是不可能了，但是达到同样的效果就 OK 了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php

class MyException extends Exception {}

set_exception_handler(function(Exception $e){
    echo &quot;Old handler:&quot;.$e-&amp;gt;getMessage();
});

$lastHandler = set_exception_handler(function(Exception $e) use (&amp;amp;$lastHandler) {
    if ($e instanceof MyException) {
        echo &quot;New handler:&quot;.$e-&amp;gt;getMessage();
        return;
    }

    if (is_callable($lastHandler)) {
        return call_user_func_array($lastHandler, [$e]);
    }
});

// throw new MyException(&quot;Exception two&quot;, 1);
throw new Exception(&quot;Exception two&quot;, 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用 PHP 的引用，把 &lt;code&gt;$lastHandler&lt;/code&gt; 引用到闭包里，这样毕竟 &lt;code&gt;set_exception_handler&lt;/code&gt; 会比闭包先运行，所以就会把前一个 &lt;code&gt;handler&lt;/code&gt; 拿到了，然后异常的时候，发现不是我的 &lt;code&gt;MyException&lt;/code&gt; 就直接调用原来的 handler 来处理就好了。&lt;/p&gt;

&lt;p&gt;然后我去回答了我之前搜索到没有答案的两个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/14411492/cannot-destroy-active-lambda-function/34181805#34181805&quot;&gt;Cannot destroy active lambda function&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12378644/how-can-i-retrieve-the-current-error-handler&quot;&gt;How can I retrieve the current error handler?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望有此想法的同学能得到帮助。 :smile:&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/12/about-set-exception-handler.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/12/about-set-exception-handler.html</guid>
        
        
      </item>
    
      <item>
        <title>让你的 Laravel 应用与官方保持同步</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;解决什么问题？&lt;/h2&gt;

&lt;p&gt;我们在用着 4.2，过了一段时间作者发布了 5.0，项目可能还没开发完，然后你又像我一样是一个不升级不舒服斯基，那么用升到最新版是你接下来要忙碌的事情。因为你不知道 4.2 ~ 5.0 变化了多少。所以你不可能手动一个个加上或者删除、修改。有的人可能是备份，然后用新版建立一个项目：&lt;code&gt;composer create-project laravel/laravel&lt;/code&gt; ，然后把原来自己的代码考过来，然而，变化不一定只是文件新增或者删除啊，可能是原来文件里改了一行，你却没法知道。所以这就头疼了。那么下面我就分享一个超简单的办法来解决这个问题：&lt;/p&gt;

&lt;p&gt;首先我们使用的是 &lt;code&gt;git&lt;/code&gt;，如果你不熟悉它的话，起码你这时候应该去补补基本命令了。&lt;/p&gt;

&lt;p&gt;这里假设我们的项目叫做 &lt;code&gt;blog&lt;/code&gt;, 然后我们第一步要做的事情是添加官方&lt;code&gt;git&lt;/code&gt;源:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd blog # 切到项目根目录
git remote add laravel https://github.com/laravel/laravel # 添加一个源
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里解释一下：&lt;/p&gt;

&lt;p&gt;因为我们的项目基本都已经有一个源&lt;code&gt;origin&lt;/code&gt;，就是我们项目用于上传到公司 &lt;code&gt;gitlab&lt;/code&gt; 或者 &lt;code&gt;bitbucket&lt;/code&gt; 这样的网站用于项目代码管理的地方，所以我们不能破坏它。然后我们添加了一个叫做 &lt;code&gt;laravel&lt;/code&gt;，这样就会有两个源了，意味着我们就可以从两个源同步代码。&lt;/p&gt;

&lt;h2 id=&quot;larvel-&quot;&gt;拉取 Larvel 的新版代码&lt;/h2&gt;

&lt;h4 id=&quot;laravel-&quot;&gt;拉取指定的 Laravel 分支&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：在我们拉取 Laravel 源的代码前，请确认你的修改都已经保存并 &lt;code&gt;commit&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;shell
  git pull laravel master
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里我们从 &lt;code&gt;laravel&lt;/code&gt; 的源拉取 &lt;code&gt;master&lt;/code&gt; 分支，当然你也可以拉取其它分支的代码。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;合并冲突&lt;/h4&gt;

&lt;p&gt;拉取完代码，这时候通常是会冲突的，因为你的代码与官方的代码不一样了，冲突部分就是不相同的地方，那么你根据合并结果找到&lt;code&gt;CONFLICT (content): Merge conflict in xxxx.xxx&lt;/code&gt; 部分的文件打开，找到冲突的地方合并就好了。&lt;/p&gt;

&lt;p&gt;解决完冲突你的代码结构就与官方一致了，而且这种合并方式不会让你落下任何一个不同的地方。&lt;/p&gt;

&lt;p&gt;当然以上的方法适用于任何 &lt;code&gt;git&lt;/code&gt; 管理的项目。比如工作中，你 &lt;code&gt;fork&lt;/code&gt; 了主项目，要经常同步主项目的更新时就用这个方法最简单了。&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/06/sync-your-laravel-project.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/06/sync-your-laravel-project.html</guid>
        
        
      </item>
    
      <item>
        <title>PHP代码规范与质量检查工具PHPCS,PHPMD的安装与配置</title>
        <description>&lt;h2 id=&quot;phpcs&quot;&gt;PHPCS&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;有以下方式安装 PHPCS:&lt;/p&gt;

&lt;h5 id=&quot;composer&quot;&gt;使用 &lt;code&gt;composer&lt;/code&gt;:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;composer global require &quot;squizlabs/php_codesniffer=*&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，你可能需要将 &lt;code&gt;~/.composer/vendor/bin/&lt;/code&gt; 添加到 PATH 环境变量中，否则会报命令找不到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;pear&quot;&gt;使用 PEAR:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;pear install PHP_CodeSniffer
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-1&quot;&gt;下载安装：&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcs.phar
php phpcs.phar -h
curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar
php phpcbf.phar -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后移动到命令目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;mv phpcs.phar /usr/bin/phpcs
mv phpcbf.phar /usr/bin/phpcbf
// 也许上面需要 sudo
chmod +x /usr/bin/phpcs
chmod +x /usr/bin/phpcbf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;phpcbf&lt;/code&gt; 是代码修复工具。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用&lt;/h3&gt;

&lt;h5 id=&quot;section-3&quot;&gt;查看帮助：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;phpcs --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-4&quot;&gt;添加标准：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;phpcs --config-set installed_paths PATH_TO_SEARCH_STANDARDS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：假设标准为 &lt;code&gt;Weibo&lt;/code&gt;, 目录为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/overtrue/code_standards/Weibo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;Weibo&lt;/code&gt; 里才是 &lt;code&gt;ruleset.xml&lt;/code&gt;，那么对应上面的 &lt;code&gt;PATH_TO_SEARCH_STANDARDS&lt;/code&gt; 应该为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpcs --config-set installed_paths /Users/overtrue/code_standards
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-5&quot;&gt;查看已经安装的标准：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;phpcs -i
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-6&quot;&gt;查看配置：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;phpcs --config-show
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-7&quot;&gt;检查代码规范：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;phpcs ./codes/Example.php
// or
phpcs ./codes/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定标准：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpcs ./codes/Example.php --standard=PSR2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报告格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpcs --report=summary /path/to/code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用的格式有（默认为: &lt;code&gt;full&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;full, xml, checkstyle, csv
json, emacs, source, summary, diff
svnblame, gitblame, hgblame or notifysend
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-8&quot;&gt;修复代码&lt;/h5&gt;

&lt;p&gt;第一种：使用 diff 形式打补丁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;phpcs --report-diff=/path/to/changes.diff /path/to/code
patch -p0 -ui /path/to/changes.diff
# patching file /path/to/code/file.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：使用 PHP Code Beautifier 和 Fixer：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpcbf /path/to/code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令会自动修复原文件，如果不想直接覆盖原文件，可以使用 &lt;code&gt;--suffix&lt;/code&gt; 指定修复后的代码后缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phpcs /path/to/code --suffix=.fixed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多 PHPCS 的使用请参考：https://github.com/squizlabs/PHP_CodeSniffer/wiki&lt;/p&gt;

&lt;h2 id=&quot;phpmd&quot;&gt;PHPMD&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;同样有以下安装方式：&lt;/p&gt;

&lt;h5 id=&quot;phar-&quot;&gt;下载 &lt;code&gt;phar&lt;/code&gt; 文件安装：&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;wget -c http://static.phpmd.org/php/latest/phpmd.phar
mv phpmd.phar /usr/bin/phpmd
chmod +x /usr/bin/phpmd
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;composer-&quot;&gt;使用 &lt;code&gt;Composer&lt;/code&gt; 安装：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;composer global require phpmd/phpmd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;检查代码质量：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# phpmd 代码路径 报告格式
phpmd /path/to/source text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者指定要检查的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# phpmd 代码路径 报告格式 规则列表
phpmd /path/to/source text codesize,unusedcode,naming
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用xml指定检查规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# phpmd 代码路径 报告格式 规则xml文件
phpmd /path/to/source text /phpmd_ruleset.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;报告格式有：
    &lt;ul&gt;
      &lt;li&gt;xml, 以 XML 格式输出；&lt;/li&gt;
      &lt;li&gt;text, 简单的文本格式；&lt;/li&gt;
      &lt;li&gt;html, 输出到单个的html；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有一个phpmd规则可参考：https://github.com/overtrue/phpmd-rulesets&lt;/p&gt;

&lt;p&gt;更多关于 PHPMD 的使用请参考：http://phpmd.org/documentation/index.html&lt;/p&gt;
</description>
        <pubDate>Mon, 18 May 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/05/install-phpcs-and-phpmd.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/05/install-phpcs-and-phpmd.html</guid>
        
        
      </item>
    
      <item>
        <title>centos 编译安装最新版 Git</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;安装依赖包&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;git-&quot;&gt;获取最新版 Git 源码包&lt;/h2&gt;

&lt;p&gt;从 https://github.com/git/git/releases 下载最新版的 zip 包或者 tar.gz 并解压：&lt;/p&gt;

&lt;p&gt;以 tar.gz 格式为例（在网页的 tar.gz 上右键复制下载链接即可）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;wget https://github.com/git/git/archive/v2.4.0.tar.gz
tar zxvf v2.4.0.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到一个 &lt;code&gt;git-2.4.0&lt;/code&gt; 的目录（版本号与下载的一致），然后进入这个目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd git-2.4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编译安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;autoconf
./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上4步请一步步来，以免出现错误不好找原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后修改 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 文件，在最后加入一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;/usr/local/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并关闭。&lt;/p&gt;

&lt;p&gt;这就安装好了，看看版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git --version
# git version 2.4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;错误处理&lt;/h2&gt;

&lt;p&gt;如果安装后报以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bash: /usr/bin/git: 没有那个文件或目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么请编辑 &lt;code&gt;/etc/profile&lt;/code&gt; 在最后加入一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;export PATH=$PATH:/usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新开窗口就好了，或者执行命令 &lt;code&gt;source /etc/profile&lt;/code&gt; 后就好了。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/05/install-latest-git-on-centos.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/05/install-latest-git-on-centos.html</guid>
        
        
      </item>
    
      <item>
        <title>sudo -Hu 执行时找不到命令的问题解决</title>
        <description>&lt;p&gt;虽然在 &lt;code&gt;/etc/profile&lt;/code&gt; 中加了全局 &lt;code&gt;PATH&lt;/code&gt;，但是在以 &lt;code&gt;sudo -Hu [username] [command]&lt;/code&gt; 执行的时候报命令不存在，原因是 &lt;code&gt;/etc/sudoers&lt;/code&gt; 中还有一个 &lt;code&gt;secure_path&lt;/code&gt; 没修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;visudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找 &lt;code&gt;secure_path&lt;/code&gt;，加入你要添加的目录，比如 &lt;code&gt;/usr/local/bin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/05/cannot-find-command-sudo-hu.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/05/cannot-find-command-sudo-hu.html</guid>
        
        
      </item>
    
      <item>
        <title>处理 Laravel 5 默认事件</title>
        <description>&lt;p&gt;Laravel 提供了很多默认事件，登录登出、数据库连接与查询、应用启动前后、缓存等等很多默认事件，本篇以用户登录事件来演示如何处理 Larvel 5 的默认事件。&lt;/p&gt;

&lt;p&gt;我们的目的：&lt;strong&gt;处理用户登录事件，在用户登录的时候给用户添加最后登录时间(&lt;code&gt;last_login_at&lt;/code&gt;)，以及最后登录的IP(&lt;code&gt;last_ip&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用户的登录事件在 Laravel 5 里的事件名称是 &lt;code&gt;auth.login&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;第一步：创建事件处理器&lt;/h3&gt;

&lt;p&gt;Laravel 5 里直接使用命令即可创建一个事件处理器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;php artisan handler:event AuthLoginEventHandler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AuthLoginEventHandler&lt;/code&gt; 是我们定义的名称，你可以随意命名(合理的)，它会创建 &lt;code&gt;app/Handlers/Events/AuthLoginEventHandler.php&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php namespace App\Handlers\Events;

use Illuminate\Contracts\Queue\ShouldBeQueued;
use Illuminate\Queue\InteractsWithQueue;

class AuthLoginEventHandler {

    /**
     * Create the event handler.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Handle the event.
     *
     * @param  Events  $event
     * @return void
     */
    public function handle(Event $event)
    {
        //
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第二步：注册监听&lt;/h3&gt;

&lt;p&gt;打开 &lt;code&gt;app/Providers/EventServiceProvider.php&lt;/code&gt;，将我们的监听添加上:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;protected $listen = [
    &#39;auth.login&#39; =&amp;gt; [
        &#39;App\Handlers\Events\AuthLoginEventHandler&#39;,
    ],
];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第三步：添加逻辑代码&lt;/h3&gt;

&lt;p&gt;我们的需求是：在用户登录的时候给用户添加最后登录时间(&lt;code&gt;last_login_at&lt;/code&gt;)，以及最后登录的IP(&lt;code&gt;last_ip&lt;/code&gt;)。
&amp;gt; 注意：这两个字段是我自己创建的
当然，这里只是举例，你可以在这里完成所有你想要的需求。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：框架默认的事件触发时的参数都可能不同，具体请查看框架源码或者参阅相关文档。
小窍门：使用 关键字 &lt;code&gt;fire(&#39;&lt;/code&gt; 在框架目录中搜索，可以得到大部分的框架事件的调用处。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里 &lt;code&gt;auth.login&lt;/code&gt; 事件框架会传递两个参数：&lt;code&gt;用户实例&lt;/code&gt;, &lt;code&gt;是否记住登录&lt;/code&gt;，所以我们修改我们刚刚创建的 &lt;code&gt;AuthLoginEventHandler.php&lt;/code&gt; 中的 &lt;code&gt;handle&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;    /**
     * 处理用户登录
     *
     * @param User    $user     用户
     * @param boolean $remember 是否记住登录
     *
     * @return void
     */
    public function handle(User $user, $remember)
    {
        $user-&amp;gt;last_login_at = Carbon::now();
        $user-&amp;gt;last_ip = $this-&amp;gt;request-&amp;gt;ip();

        //TODO:其它动作，比如增加积分等等。

        $user-&amp;gt;save();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上面我们用到了 &lt;code&gt;Illuminate\Http\Request&lt;/code&gt; 对象，所以我们还需要添加一个属性 &lt;code&gt;protected $request&lt;/code&gt;，然后从构造方法 &lt;code&gt;__construct&lt;/code&gt; 让框架注入进来（由框架完成注入）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;    ...

    /**
     * Request 对象
     *
     * @var Illuminate\Http\Request
     */
    protected $request;

    /**
     * Create the event handler.
     *
     * @return void
     */
    public function __construct(Request $request)
    {
        $this-&amp;gt;request = $request;
    }

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所有用到的类请记得引入。最后完整的 &lt;code&gt;AuthLoginEventHandler.php&lt;/code&gt; 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php namespace App\Handlers\Events;

use Illuminate\Contracts\Queue\ShouldBeQueued;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Http\Request;
use App\Models\User;
use Carbon\Carbon;

class AuthLoginEventHandler {

    /**
     * Request 对象
     *
     * @var Illuminate\Http\Request
     */
    protected $request;

    /**
     * Create the event handler.
     *
     * @return void
     */
    public function __construct(Request $request)
    {
        $this-&amp;gt;request = $request;
    }

    /**
     * 处理用户登录
     *
     * @param User    $user     用户
     * @param boolean $remember 是否记住登录
     *
     * @return void
     */
    public function handle(User $user, $remember)
    {
        $user-&amp;gt;last_login_at = Carbon::now();
        $user-&amp;gt;last_ip = $this-&amp;gt;request-&amp;gt;ip();

        //TODO:其它动作，比如增加积分等等。

        $user-&amp;gt;save();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在用户登录的时候就会自动给用户字段 &lt;code&gt;last_login_at&lt;/code&gt; 和 &lt;code&gt;last_ip&lt;/code&gt; 补充内容了。是不是很方便呢？&lt;/p&gt;
</description>
        <pubDate>Fri, 17 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/04/laravel-login-event-handler.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/04/laravel-login-event-handler.html</guid>
        
        
      </item>
    
      <item>
        <title>Laravel 获取当前控制器名称或方法</title>
        <description>&lt;p&gt;我们有时候需要获取当前 Laravel 项目的控制器或者方法名，框架默认是不会提供单独的方法的，框架只提供了如下的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;\Route::current()-&amp;gt;getActionName();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;App\Http\Controllers\WelcomeController@index
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是这不是我们想要的，我们只想获取控制器名或者方法名，那么，你可以自定义下面三个函数来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/**
 * 获取当前控制器名
 *
 * @return string
 */
public function getCurrentControllerName()
{
    return getCurrentAction()[&#39;controller&#39;];
}

/**
 * 获取当前方法名
 *
 * @return string
 */
public function getCurrentMethodName()
{
    return getCurrentAction()[&#39;method&#39;];
}

/**
 * 获取当前控制器与方法
 *
 * @return array
 */
public function getCurrentAction()
{
    $action = \Route::current()-&amp;gt;getActionName();
    list($class, $method) = explode(&#39;@&#39;, $action);

    return [&#39;controller&#39; =&amp;gt; $class, &#39;method&#39; =&amp;gt; $method];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外推荐近期完成的两个 Laravel 拓展包：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/overtrue/laravel-lang&quot;&gt;overtrue/laravel-lang&lt;/a&gt; 基于 &lt;a href=&quot;https://github.com/caouecs/Laravel4-lang&quot;&gt;Laravel4-lang&lt;/a&gt; 的 44 语种语言文件&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/overtrue/laravel-pinyin&quot;&gt;overtrue/laravel-pinyin&lt;/a&gt; Laravel 中文转拼音， 基于 &lt;a href=&quot;https://github.com/overtrue/pinyin&quot;&gt;overtrue/pinyin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 19 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/03/get-current-controller-of-laravel.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/03/get-current-controller-of-laravel.html</guid>
        
        
      </item>
    
      <item>
        <title>使用PHP脚本远程部署git项目</title>
        <description>&lt;p&gt;2015第一篇文章，没啥技术含量，权当作个笔记。&lt;/p&gt;

&lt;p&gt;我们通常在一些git托管网站托管我们的代码，除了大家耳熟能详的&lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt;, 还有国外的&lt;a href=&quot;https://bitbucket.org/&quot;&gt;Bitbucket&lt;/a&gt;等，国内的&lt;a href=&quot;http://git.oschina.net/&quot;&gt;开源中国&lt;/a&gt;、&lt;a href=&quot;https://coding.net/&quot;&gt;Coding&lt;/a&gt;等都是不错的选择。&lt;/p&gt;

&lt;p&gt;今天以Coding上私有库的部署为例来讲解如何使用Coding的hook服务来自动部署到生产环境的服务器。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;准备工作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在Coding.net上创建一个私有库&lt;/li&gt;
  &lt;li&gt;安装了web服务与git服务的服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;在服务器上&lt;/h2&gt;

&lt;p&gt;1.创建web服务器用户目录，这里以apache用户为例，不同的环境请根据自己环境自行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; sudo mkdir /var/www/.ssh
 sudo chown -R apache:apache /var/www/.ssh/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成公钥&lt;/p&gt;

&lt;p&gt;公钥有两个：1. git用户公钥，2. 部署公钥：&lt;/p&gt;

&lt;p&gt;3.用户公钥（用于git clone时认证权限）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; ssh-keygen -t rsa -C &quot;anzhengchao@gmail.com&quot;
 # 然后一直回车就行
 # 生成的文件通常是 /root/.ssh/id_rsa，如果非root用户请查看提示上的路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.部署公钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; sudo -Hu apache ssh-keygen -t rsa # 请选择 &quot;no passphrase&quot;，一直回车下去
 sudo cat /var/www/.ssh/id_rsa.pub # 查看生成的密钥内容，复制全部
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.准备钩子文件&lt;/p&gt;

&lt;p&gt;在你的www目录建立一个目录&lt;code&gt;hook&lt;/code&gt;, 里面放上一个php文件&lt;code&gt;index.php&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/overtrue/0bf1cd704bf804de2e2c.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;在此目录下建立一个目录&lt;code&gt;repos&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; mkdir repos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改目录权限：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; chown -R apache:apache /www/hook # 这里请改成你创建的hook目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确保你的hook文件可以访问：http://example.com/hook/index.php，钩子准备完成。&lt;/p&gt;

&lt;p&gt;4.修改git配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt; git config --global user.name &quot;overtrue&quot; 
 git config --global user.email &quot;anzhengchao@gmail.com&quot; # 邮箱请与conding上一致
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;在代码托管网站&lt;/h2&gt;

&lt;p&gt;1.添加用户公钥&lt;/p&gt;

&lt;p&gt;复制上面的&lt;code&gt;/root/.ssh/id_rsa.pub&lt;/code&gt;的内容到个人设置页&lt;code&gt;https://coding.net/user/setting/keys&lt;/code&gt;添加即可&lt;/p&gt;

&lt;p&gt;2.复制&lt;code&gt;/var/www/.ssh/id_rsa.pub&lt;/code&gt;的内容并添加到Coding.net公钥:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择项目 &amp;gt; 设置 &amp;gt; 部署公钥 &amp;gt; 新建 &amp;gt; 粘贴到下面框并确认&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.添加hook&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择项目 &amp;gt; 设置 &amp;gt; WebHook &amp;gt; 新建hook &amp;gt; 粘贴你的hook/index.php所在的网址。比如:http://example.com/hook/index.php, 令牌可选，但是建议写上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;稍过几秒刷新页面查看hook状态，显示为绿色勾就OK了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;初始化&lt;/h2&gt;

&lt;p&gt;1.我们需要先在服务器上clone一次，以后都可以实现自动部署了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;  sudo chown -R apache:apache /www/hook/repos
  sudo -Hu apache git clone git@coding.net:you/repo.git /www/hook/repos/  --depth=1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;**！！注意，这里初始化clone必须要用www用户**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.往Coding.net提交一次代码测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;  git commit -am &quot;test hook&quot; --allow-empty
  git push 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，稍微一几秒，正常的话你在代码里配置的目标目录里就会有你的项目文件了。&lt;/p&gt;

&lt;p&gt;有问题请随时反馈：https://gist.github.com/overtrue/0bf1cd704bf804de2e2c&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://127.0.0.1:4000//a/2015/01/how-to-deploy-project-with-git-hook.html</link>
        <guid isPermaLink="true">http://127.0.0.1:4000//a/2015/01/how-to-deploy-project-with-git-hook.html</guid>
        
        
      </item>
    
  </channel>
</rss>
